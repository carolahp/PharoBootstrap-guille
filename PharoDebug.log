THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfPharoBootstrapProcess [BaselineOfPharoBootstrapProcess] in /Users/guille/Projects/boot_jit/PharoBootstrap/pharo-local/package-cache filetree:///Users/guille/Projects/boot_jit/PharoBootstrap
6 April 2021 11:48:51.760162 pm

VM: Mac OS - intel - 1014.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121043 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:43:20 2020 CommitHash: 52202d8 Plugins: 202002121043 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1145.sha.7dc39ed9e28dda58cf139f1723f350d5361d9b0f (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'file...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'file...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	ni
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfPharoBootstrapProcess'
		bar: 	a Jo
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


BlockClosure>>cull:
	Receiver: [ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displ...etc...
		startpc: 	46
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfPharoBootstrapProcess'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	47
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfPharoBootstrapProcess'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	41
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ]
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Fetching BaselineOfPharoBootstrapProcess'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


NonInteractiveUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a NonInteractiveUIManager
	Arguments and temporary variables: 
		titleString: 	'Fetching BaselineOfPharoBootstrapProcess'
		minVal: 	0
		maxVal: 	2
		workBlock: 	[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	nil


ByteString(String)>>displayProgressFrom:to:during:
	Receiver: 'Fetching BaselineOfPharoBootstrapProcess'
	Arguments and temporary variables: 
		minVal: 	0
		maxVal: 	2
		workBlock: 	[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 
	Receiver's instance variables: 
'Fetching BaselineOfPharoBootstrapProcess'

IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfPharoBootstrapProcess
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'file...etc...
		gofer: 	a MetacelloGofe
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://.'.
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstr...etc...
		gofer: 	a MetacelloGofe
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	reposit...etc...
		repositories: 	an OrderedCollection(a MCFileTreeRepository(filetree:///Users/gui...etc...
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://....etc..
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://.'.)
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://.'.)

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	reposit...etc...
		repositories: 	an OrderedCollection(a MCFileTreeRepository(filetree:///Users/gui...etc...
		gofer: 	a MetacelloGofe
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	reposit...etc...
		repositories: 	an OrderedCollection(a MCFileTreeRepository(filetree:///Users/gui...etc...
		directive: 	ni
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfPharoBootstrapProcess
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfPharoBootstrapProces
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfPharoBootstrapProcess
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstr...etc...
		directive: 	explicit load : BaselineOfPharoBootstrapProces
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfPharoBootstrapProcess
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfPharoBootstrapProcess)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfPharoBootstrapProcess';
	reposit...etc...
		repositories: 	an OrderedCollection(a MCFileTreeRepository(filetree:///Users/gui...etc...
		directive: 	ni
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://.'.
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfP...etc..
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfPharoBootstrapProcess';
	repository: 'filetree://.'.
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc..
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	ni
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	fals
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngin
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'.
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'.
		version: 	ni
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc..
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc..
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc..
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc..
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'PharoBootstrapProcess';
	repository: 'filetree://.'....etc...
		options: 	a Dictionary()



--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
[ :bar | 
bar value: 1.
aBlock value.
bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
NonInteractiveUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
BlockClosure>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OpalCompiler>>evaluate
OpalCompiler>>evaluate:
[ result := Smalltalk compiler evaluate: aStream.
self hasSessionChanged
	ifFalse: [ self stdout
			print: result;
			lf ] ] in EvaluateCommandLineHandler>>evaluate:
BlockClosure>>on:do:
EvaluateCommandLineHandler>>evaluate:
EvaluateCommandLineHandler>>evaluateArguments
EvaluateCommandLineHandler>>activate
EvaluateCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ aCommandLinehandler activateWith: commandLine ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
BlockClosure>>on:do:
PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:
PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand
PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:
[ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ] in [ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
BlockClosure>>on:do:
[ [ self
	handleArgument:
		(self arguments
			ifEmpty: [ '' ]
			ifNotEmpty: [ :arguments | arguments first ]) ]
	on: Exit
	do: [ :exit | 
		"If the command line is protected by password, we just exit the image because in non-headless mode the handleExit will let the image open. If the password protection is enabled, it is to avoid to let the access to the image."
		self class commandLinePasswordManager hasPasswordSet
			ifTrue: [ Smalltalk snapshot: false andQuit: true ].
		^ self handleExit: exit ] ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

Processes and their stacks: 
Process: a Process in InputEventFetcher>>waitForInput
  stack:

InputEventFetcher>>waitForInput
InputEventFetcher>>eventLoop
[ self eventLoop ] in InputEventFetcher>>installEventLoop
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
  stack:

[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
  stack:

DelayMicrosecondTicker>>waitForUserSignalled:orExpired:
[ [ runTimerEventLoop ]
	whileTrue: [ | nowTick |
		"Warning! Stepping <Over> the following line may lock the Image. Use <Into> or <Proceed>."
		ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay.

		"When two debuggers appear, step/proceed through this higher priority one first."
		debug
			ifTrue: [ self halt ].

		"Invoke the api back-ends, which set the transfer-variable to nil"
		suspendSemaphore ifNotNil: [ self suspendAtTimingPriority ].
		delayToStart ifNotNil: [ self scheduleAtTimingPriority ].
		delayToStop ifNotNil: [ self unscheduleAtTimingPriority ].

		"Signal any expired delays"
		nowTick := ticker nowTick.
		[ activeDelay notNil and: [ nowTick >= activeDelay resumptionTick ] ]
			whileTrue: [ activeDelay timingPrioritySignalExpired.
				activeDelay := suspendedDelays removeFirstOrNil ] ] ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
BlockClosure>>ensure:
DelaySemaphoreScheduler(DelayBasicScheduler)>>runBackendLoopAtTimingPriority
[ self runBackendLoopAtTimingPriority ] in DelaySemaphoreScheduler(DelayBasicScheduler)>>startTimerEventLoopPriority:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in Process>>terminate
  stack:

Process>>terminate
------------------------------

Process: a Process in SmalltalkImage>>lowSpaceWatcher
  stack:

SmalltalkImage>>lowSpaceWatcher
[ self lowSpaceWatcher ] in SmalltalkImage>>installLowSpaceWatcher
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
  stack:

[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in WeakArray class>>finalizationProcess
  stack:

WeakArray class>>finalizationProcess
[ self finalizationProcess ] in WeakArray class>>restartFinalizationProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
------------------------------

Process: a Process in nil
  stack:

Array(SequenceableCollection)>>do:
[ :logger | 
logger
	nextPutAll: 'Processes and their stacks: ';
	cr.
Process allInstances
	do: [ :each | 
		| ctx |
		logger
			nextPutAll: 'Process: ';
			print: each;
			cr;
			nextPutAll: '  stack:';
			cr;
			cr.
		ctx := each isActiveProcess
			ifTrue: [ thisContext sender ]
			ifFalse: [ each suspendedContext ].
		ctx
			ifNotNil: [ (ctx stackOfSize: 20)
					do: [ :s | 
						logger
							print: s;
							cr ] ].
		logger
			nextPutAll: '------------------------------';
			cr;
			cr ] ] in [ Smalltalk logError: aString inContext: aContext.

" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ (ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
[ logStream := self openLog.
aMonadicBlock value: logStream ] in SmalltalkImage>>logDuring:
BlockClosure>>ensure:
SmalltalkImage>>logDuring:
[ Smalltalk logError: aString inContext: aContext.

" Print stacks of all current processes "
Smalltalk
	logDuring: [ :logger | 
		logger
			nextPutAll: 'Processes and their stacks: ';
			cr.
		Process allInstances
			do: [ :each | 
				| ctx |
				logger
					nextPutAll: 'Process: ';
					print: each;
					cr;
					nextPutAll: '  stack:';
					cr;
					cr.
				ctx := each isActiveProcess
					ifTrue: [ thisContext sender ]
					ifFalse: [ each suspendedContext ].
				ctx
					ifNotNil: [ (ctx stackOfSize: 20)
							do: [ :s | 
								logger
									print: s;
									cr ] ].
				logger
					nextPutAll: '------------------------------';
					cr;
					cr ] ] ] in NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
BlockClosure>>ensure:
NonInteractiveUIManager(CommandLineUIManager)>>quitFrom:withMessage:
NonInteractiveUIManager(CommandLineUIManager)>>unhandledErrorDefaultAction:
UnhandledError>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
UnhandledError(Exception)>>signal
UnhandledError class>>signalForException:
MetacelloPackageSpecResolutionError(Error)>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
MetacelloPackageSpecResolutionError(Exception)>>pass
------------------------------

